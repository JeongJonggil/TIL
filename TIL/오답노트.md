# 기본 오답 노트

1. 딘순히 input만으로는 한 번에 여러개의 변수를 받을 수 없다.
   한 번에 여러개 변수를 받기 위해서는 list, map, split 등을 활용해야 한다
   
2. if 조건식을 만족하는 코드블럭 안에서는 새로운 변수를 선언하는게 가능하지만, if 조건식을 만족하지 않는 코드블럭에서 새로운 변수 선언시 에러가 뜸

3. 조건식에 함수를 사용하면 (ex. `if 사용자정의함수:`) 사용자정의 함수가 호출되어 함수의 코드블럭 전체가 우선 실행된다.

4. dictionary에서 key값은 불변, value 값은 가변이다. 그 중에서도 '**value 값이 리스트 타입**'이라면 '**변수명['key명'].append()**'가 사용 가능하다.

5. 단축평가 : 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작  
   (1) and 앞 부분이 False(0)이면 뒤는 볼 필요도 없음(뒤 값 무시(평가되지 않음)) -> 결과 False(0) 고정  
   (2) and 앞 부분이 True 이면 뒤가 False(0)인지 True인지가 중요해짐 -> 결과가 뒤에 있는 값으로 나옴  
   (3) or 앞 부분이 True이면 뒤 볼 필요 없이 True임(뒤 값 무시(평가되지 않음)) -> 결과가 앞에 있는 값으로 나옴  
   (4) or 앞 부분이 False(0)이면 뒤 값이 중요해짐 -> 결과가 뒤에 있는 값으로 나옴  


#시험 오답노트  
1.set, dictionary도 형변환이 가능함. dictionary의 경우 별도의 언급이 없으면 key 값만 반환함. dictionary명.items()로 형변환 하면 (key,value)로 묶어서 형변환  
   (ex) tuple(dictionary) → (key1, key2, key3) → key 값만 tuple로 반환  
   (ex) tuple(dictionary.items()) → ((key1,value1), (key2,value2), (key3,value3)) → (key,value)를 tuple로 반환  

2. 리스트 슬라이싱 [시작:끝:간격] 에서 간격이 음수이면 역순으로 슬라이싱하는 것이 가능하므로 시작인덱스가 끝 인덱스보다 작아도 되지만,  
   간격이 양수인 경우에는 반드시 시작인덱스가 끝 인덱스보다 작아야 됨(아니면 빈 리스트로 출력 됨)  

3. 함수 인자로 넘길때 리스트 언패킹으로 바로 넘기면 , 없이도 함수가 실행됨  
   ```
   (ex)  
      def total(input1, input2)  
         return input1 + input2  

      ls = [3,4]  
      print(*ls) #3 4  
      print(total(*ls)) #7 → *ls를 하면 3 4로 돼서 인자로 넣을 때는 3, 4 이런식으로 ,를 넣어야 될꺼 같은데 저렇게 해도 그냥 돌아감
   ```
