# 7. 그래프 이론

### 0. 발상

- 그래프 : 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조

- **''서로 다른 개체가 연결되어 있다''라는 이야기를 듣거나 떠오르면 그래프 알고리즘을 의심해 보기**

  

### 1. 그래프 vs 트리

|                     |             그래프             |       트리       |
| :-----------------: | :----------------------------: | :--------------: |
|       방향성        | 방향 그래프 혹은 무방향 그래프 |   방향 그래프    |
|       순환성        |         순환 및 비순환         |      비순환      |
| 루트 노드 존재 여부 |        루트 노드가 없음        | 루트 노드가 존재 |
|    노드간 관계성    |     부모와 자식 관계 없음      | 부모와 자식 관계 |
|     모델의 종류     |         네트워크 모델          |    계층 모델     |



### 2. 인접 행렬 vs 인접 리스트

- 노드의 개수 V, 간선의 개수 E 인 경우

  - 인접 행렬 : 메모리 O(V<sup>2</sup>) , 간선 확인 시간 O(1)
  - 인접 리스트 : 메모리 O(E), 간선 확인 시간 O(V)

  

### 3. 서로소 집합(Disjoint Sets)

​	(1) 서로소 집합(Disjoint Sets)

​		: 공통 원소가 없는 두 집합

​	(2) 서로소 집합 자료구조(Union-Find 자료구조) 

​		● 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조, **트리 자료구조를 이용하여 집합을 표현함**

​		● 스택과 큐가 push, pop 2개로 동작하는 것처럼, **서로소 집합 자료구조는 union과 find 2개의 연산으로 조작함**



### 4. 서로소 집합 계산 알고리즘(Union-Find)

```tex
● union(합집합) : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
● find(찾기) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산


# 알고리즘
1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A,B를 확인한다.
	(1) A와 B의 루트 노드 A',B'를 각각 찾는다.
	(2) A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다)
2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.

※ 실제로 구현할 때는 더 번호가 작은 원소가 부모 노드가 되도록 구현하는게 일반적임
(반대로 해도 상관 없음)
```

```python
# 서로소 집합 알고리즘 소스코드

def find_parent(parent,x): # 특정 원소가 속한 집합 찾기
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        parent[x] = find_parent(parent,parent[x])
    return parent[x]

def union_parent(parent,a,b) # 두 원소가 속한 집합을 합치기
    a = find_parent(parent,a)
    b = find_parent(parent,b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int,input().split())
parent = [0] * (v+1) #부모 테이블 초기화

# 부모 테이블 상에서, 부모를 자기 자신으로 초기화
for i in range(1, v+1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a,b= map(int,input.split())
    union_parent(parent,a,b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합 : ', end = ' ')
for i in range(1,V+1):
    print(find_parent(parent,i), end = ' ')

print()

# 부모 테이블 출력
print('부모테이블 :', end = ' ')
print(*parent)
```



※ 참고

- 서로소 집합을 활용해서 사이클(순환) 반별 소스코드 (279page 참고)

  - 위의 서로소 집합 알고리즘 소스코드에서 ''부모를 자기 자신으로 초기화' ' 다음 순서 부분 아래 코드로 바꾸면 됨

  ```python
  # 사이클(순환) 판별 소스코드
  cycle = False # 사이클 발생 여부
  
  for i in range(e):
  	a,b = map(int,input().split())
      # 사이클 발생한 경우 종료
      if find_parent(parent,a) == find_parent(parent,b):
          cycle = True
          break
      # 사이클이 발생하지 않았다면 합집합(union) 수행
  	else:
          union_parent(parent,a,b)
      
  if cycle:
      print("사이클")
  else:
      print("사이클 없음")
  ```

  

### 5. 신장 트리

- 신장트리 : 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프 



### 6. 크루스칼 알고리즘





